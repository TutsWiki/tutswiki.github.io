<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DSA on TutsWiki Beta</title><link>https://tutswiki.com/tags/dsa/</link><description>Recent content in DSA on TutsWiki Beta</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Fri, 13 Nov 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tutswiki.com/tags/dsa/index.xml" rel="self" type="application/rss+xml"/><item><title>Insertion Sort</title><link>https://tutswiki.com/data-structures-algorithms/insertion-sort/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/insertion-sort/</guid><description>Now when there are sorting algorithms already available like Merge Sort and Quick Sort which can sort a large number of elements in quick time and that too efficiently in most of the cases, we still might require to rely on other sorting techniques in some cases. Today we will discuss one such sorting technique called Insertion Sort. Insertion sort is one of the easiest and efficient sorting algorithms that is a comparison based sorting technique.</description></item><item><title>Bubble Sort</title><link>https://tutswiki.com/data-structures-algorithms/bubble-sort/</link><pubDate>Fri, 13 Nov 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/bubble-sort/</guid><description>The most basic and easy to implement sorting technique is Bubble Sort. It works by simply comparing each and every element and gets its name from the way in which the smaller elements bubble to the starting of the array.
Understanding Bubble Sort Every possible pair is compared and swapping is performed if required, that is, if there are &amp;lsquo;n&amp;rsquo; elements then n*n comparisons will be done, though it&amp;rsquo;s time-consuming, it places elements in their correct indexes in the end.</description></item><item><title>Radix Sort</title><link>https://tutswiki.com/data-structures-algorithms/radix-sort/</link><pubDate>Sat, 31 Oct 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/radix-sort/</guid><description>Radix Sort is another sorting technique from the family of Linear Sorting Algorithms.
It sorts elements using their place values from the LSB (Least Significant Bit) to MSB (Most Significant Bit), we use Counting sort as a sub-routine to sort elements according to place values. We can also use any other sorting algorithms, but since Counting sort provides linear time complexity in this case, we prefer the same.
Understanding Radix Sort Algorithm We already know how counting sort sorts elements by counting occurrences of respective elements, we use the same concept here but we don&amp;rsquo;t directly apply counting sort on elements, rather we apply it digit by digit, that is, first we apply on ones place, then on tens place, then hundreds and so on.</description></item><item><title>Bucket Sort</title><link>https://tutswiki.com/data-structures-algorithms/bucket-sort/</link><pubDate>Tue, 20 Oct 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/bucket-sort/</guid><description>We saw how Counting Sort sorts elements in linear time, another such sorting technique is Bucket Sort and is an improvised version of the same.
In this algorithm we create buckets within a certain range and assign elements accordingly, after this we apply some sorting technique to sort elements in buckets.
Understanding Bucket Sort Algorithm The given array is divided into buckets and then these buckets are sorted individually.</description></item><item><title>Counting Sort</title><link>https://tutswiki.com/data-structures-algorithms/counting-sort/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/counting-sort/</guid><description>Counting sort is one of the very few sorting algorithms that can sort elements in almost linear time.
It works by counting the frequency of elements, storing it in an auxiliary array, and finding an appropriate place for each element with the help of this count array.
Counting sort works best for small range values, but its linear time complexity doesn&amp;rsquo;t guarantee that it will work faster than other sorting algorithms in all cases, as the length of count array is equal to the max element of the array, which can turn out to be very large at times.</description></item><item><title>Quick Sort</title><link>https://tutswiki.com/data-structures-algorithms/quick-sort/</link><pubDate>Tue, 29 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/quick-sort/</guid><description>Quick sort is one of the most widely used and efficient sorting algorithms. It is a divide and conquer technique, that means, we divide a problem into sub-problems and then solve them accordingly.
This sorting algorithm includes selecting a pivot point and finding its appropriate place in the array by putting elements smaller to it on its left side, and the elements greater than it to its right side. We then create a partition around this correct position of pivot.</description></item><item><title>Heap Sort</title><link>https://tutswiki.com/data-structures-algorithms/heap-sort/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/heap-sort/</guid><description>Sorting as you might already know is basically an algorithm that is used for arranging elements of a list in a certain order. (Usually ascending or descending). Sorting is one of the most important categories of algorithms, it can significantly reduce the complexity of problems, and is generally used for efficient searching.
There are an ample number of sorting algorithms available like the Bubble sort, Selection sort, Insertion sort, Merge sort, Quick sort, Heap sort, Counting sort and more.</description></item><item><title>Merge Sort</title><link>https://tutswiki.com/data-structures-algorithms/merge-sort/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/merge-sort/</guid><description>Merge sort is a popular sorting algorithm which uses divide and conquer algorithm. Consider an array A to be sorted. We divide the array A into two parts and sort them individually. The heart of the Merge Sort is a procedure called Merge. Let&amp;rsquo;s see the Merge procedure first and then we will use Merge as a subroutine to implement Merge Sort algorithm.
Merge Procedure Here sub-array_1 A[p,q] and sub-array-2 A[q+1,r] are sorted individually and we want to sort them as a whole.</description></item><item><title>Tree Data Structure</title><link>https://tutswiki.com/data-structures-algorithms/tree-data-structure/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/tree-data-structure/</guid><description>Data structures are different ways in which we can store or organise data. They can be classified into broadly two types.
1. Linear Data Structures Data structures in which data is stored in the sequential arrangement are called linear data structures. For example arrays, linked lists, queues etc. Please note that this does not imply storing data in consecutive locations. Data can be stored anywhere in the memory, though the linked list is a linear data structure, it does not store data in contiguous memory locations.</description></item><item><title>Binary Search Tree</title><link>https://tutswiki.com/data-structures-algorithms/binary-search-tree/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/binary-search-tree/</guid><description>Previous article gave the Introduction to Trees and BST. This article will explain some important operations on BST.
Binary Search Trees are special types of binary trees where the value of every node in the left subtree is less than the value of the root node as well as the value of every node in the right subtree is greater than the value of the root node.
Structure Structure of a BST node is like following:</description></item><item><title>Binary Search</title><link>https://tutswiki.com/data-structures-algorithms/binary-search/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/binary-search/</guid><description>Generally if we are asked to perform searching, what we do is take every element one by one and compare with the input value. This in computing terms is called Linear Search.
But do we really need to compare to every element in, specially in cases where number of elements are huge?
Let&amp;rsquo;s take an example of dictionary. Now we know that a dictionary contains thousands of words, and if we are required to search a particular word, we don&amp;rsquo;t go scanning every word in dictionary, but follow a planned approach and get towards the required word.</description></item><item><title>Interpolation Search</title><link>https://tutswiki.com/data-structures-algorithms/interpolation-search/</link><pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/interpolation-search/</guid><description>No doubt Binary Search is one the best searching algorithms providing average runtime of O(log n), but still there are cases where more efficient searching could be performed.
Let&amp;rsquo;s discuss one such scenario.
Consider two arrays:
Array 1: 1 3 8 9 12 14 27 29 34 37
Array 2: 10 20 30 40 50 60 70 80 90 100 110 120
Both of the above arrays are sorted in ascending order, but if you observe closely Array 1 is not uniformly distributed, but Array 2 is uniformly distributed, that is, the elements in Array 2 are placed in regular intervals of equal size, in our case 10.</description></item><item><title>Exponential Search</title><link>https://tutswiki.com/data-structures-algorithms/exponential-search/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/exponential-search/</guid><description>The term Exponential generally denotes rapid growth, and mathematically it means increasing in powers.
For example:
Exponential growth of 2: 2^0, 2^1, 2^2, 2^3, 2^4 and so on =&amp;gt; (1, 2, 4, 8, 16,&amp;hellip;..)
Exponential growth of 3: 3^0, 3^1, 3^2, 3^3, 3^4 and so on =&amp;gt; (1, 3, 9, 27, 81,&amp;hellip;.)
We use the same generated numbers ( powers of 2 ) to jump indexes in array and get closer to the index of key.</description></item></channel></rss>