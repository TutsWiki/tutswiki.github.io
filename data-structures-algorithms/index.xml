<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>DSA on TutsWiki Beta</title><link>https://tutswiki.com/data-structures-algorithms/</link><description>Recent content in DSA on TutsWiki Beta</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 22 Sep 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://tutswiki.com/data-structures-algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Insertion Sort</title><link>https://tutswiki.com/data-structures-algorithms/insertion-sort/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/insertion-sort/</guid><description>Now when there are sorting algorithms already available like Merge Sort and Quick Sort which can sort a large number of elements in quick time and that too efficiently in most of the cases, we still might require to rely on other sorting techniques in some cases. Today we will discuss one such sorting technique called Insertion Sort. Insertion sort is one of the easiest and efficient sorting algorithms that is a comparison based sorting technique.</description></item><item><title>Heap Sort</title><link>https://tutswiki.com/data-structures-algorithms/heap-sort/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/heap-sort/</guid><description>Sorting as you might already know is basically an algorithm that is used for arranging elements of a list in a certain order. (Usually ascending or descending). Sorting is one of the most important categories of algorithms, it can significantly reduce the complexity of problems, and is generally used for efficient searching.
There are an ample number of sorting algorithms available like the Bubble sort, Selection sort, Insertion sort, Merge sort, Quick sort, Heap sort, Counting sort and more.</description></item><item><title>Merge Sort</title><link>https://tutswiki.com/data-structures-algorithms/merge-sort/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/merge-sort/</guid><description>Merge sort is a popular sorting algorithm which uses divide and conquer algorithm. Consider an array A to be sorted. We divide the array A into two parts and sort them individually. The heart of the Merge Sort is a procedure called Merge. Let&amp;rsquo;s see the Merge procedure first and then we will use Merge as a subroutine to implement Merge Sort algorithm.
Merge Procedure Here sub-array_1 A[p,q] and sub-array-2 A[q+1,r] are sorted individually and we want to sort them as a whole.</description></item><item><title>Tree Data Structure</title><link>https://tutswiki.com/data-structures-algorithms/tree-data-structure/</link><pubDate>Sat, 22 Aug 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/tree-data-structure/</guid><description>Data structures are different ways in which we can store or organise data. They can be classified into broadly two types.
1. Linear Data Structures Data structures in which data is stored in the sequential arrangement are called linear data structures. For example arrays, linked lists, queues etc. Please note that this does not imply storing data in consecutive locations. Data can be stored anywhere in the memory, though the linked list is a linear data structure, it does not store data in contiguous memory locations.</description></item><item><title>Binary Search Tree</title><link>https://tutswiki.com/data-structures-algorithms/binary-search-tree/</link><pubDate>Tue, 08 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/binary-search-tree/</guid><description>Previous article gave the Introduction to Trees and BST. This article will explain some important operations on BST.
Binary Search Trees are special types of binary trees where the value of every node in the left subtree is less than the value of the root node as well as the value of every node in the right subtree is greater than the value of the root node.
Structure Structure of a BST node is like following:</description></item><item><title>Binary Search</title><link>https://tutswiki.com/data-structures-algorithms/binary-search/</link><pubDate>Thu, 10 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/binary-search/</guid><description>Generally if we are asked to perform searching, what we do is take every element one by one and compare with the input value. This in computing terms is called Linear Search.
But do we really need to compare to every element in, specially in cases where number of elements are huge?
Let&amp;rsquo;s take an example of dictionary. Now we know that a dictionary contains thousands of words, and if we are required to search a particular word, we don&amp;rsquo;t go scanning every word in dictionary, but follow a planned approach and get towards the required word.</description></item><item><title>Interpolation Search</title><link>https://tutswiki.com/data-structures-algorithms/interpolation-search/</link><pubDate>Thu, 17 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/interpolation-search/</guid><description>No doubt Binary Search is one the best searching algorithms providing average runtime of O(log n), but still there are cases where more efficient searching could be performed.
Let&amp;rsquo;s discuss one such scenario.
Consider two arrays:
Array 1: 1 3 8 9 12 14 27 29 34 37
Array 2: 10 20 30 40 50 60 70 80 90 100 110 120
Both of the above arrays are sorted in ascending order, but if you observe closely Array 1 is not uniformly distributed, but Array 2 is uniformly distributed, that is, the elements in Array 2 are placed in regular intervals of equal size, in our case 10.</description></item><item><title>Exponential Search</title><link>https://tutswiki.com/data-structures-algorithms/exponential-search/</link><pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate><guid>https://tutswiki.com/data-structures-algorithms/exponential-search/</guid><description>In this algorithm, ultimately we rely on Binary Search for searching, but before that, we finalize a range in which the element we want to search might be present.
To finalize this range we follow a certain algorithm, let&amp;rsquo;s have a quick look at the overview of working of this algorithm with the help of an example.
Understanding Exponential Search Consider a sorted Array: 7 12 34 57 65 74 81 88 89 93 100</description></item></channel></rss>